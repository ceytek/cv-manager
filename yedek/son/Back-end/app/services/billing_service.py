"""
Billing Service
Handles payment transactions and invoice generation
"""
from typing import Optional, List
from uuid import UUID
from datetime import datetime, date
from decimal import Decimal
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.transaction import Transaction, TransactionStatus, PaymentMethod
from app.models.subscription import CompanySubscription, SubscriptionPlan
from app.services.subscription_service import SubscriptionService


class BillingService:
    """Service for managing billing and transactions"""
    
    @staticmethod
    async def create_transaction(
        db: AsyncSession,
        company_id: UUID,
        amount: Decimal,
        transaction_type: str,
        currency: str = 'TRY',
        subscription_id: Optional[UUID] = None,
        payment_method: Optional[PaymentMethod] = None,
        description: Optional[str] = None,
        metadata: Optional[dict] = None,
        created_by: Optional[UUID] = None
    ) -> Transaction:
        """
        Create a new transaction record
        
        Args:
            db: Database session
            company_id: Company UUID
            amount: Transaction amount
            transaction_type: 'subscription', 'upgrade', 'renewal', 'refund'
            currency: Currency code (default: TRY)
            subscription_id: Optional subscription UUID
            payment_method: Payment method enum
            description: Transaction description
            metadata: Additional transaction data
            created_by: User who created the transaction
        
        Returns:
            Created Transaction object
        """
        transaction = Transaction(
            company_id=company_id,
            subscription_id=subscription_id,
            transaction_type=transaction_type,
            amount=amount,
            currency=currency,
            payment_method=payment_method,
            status=TransactionStatus.PENDING,
            description=description,
            transaction_metadata=metadata or {},
            created_by=created_by
        )
        
        db.add(transaction)
        await db.commit()
        await db.refresh(transaction)
        
        return transaction
    
    @staticmethod
    async def complete_transaction(
        db: AsyncSession,
        transaction_id: UUID,
        payment_reference: Optional[str] = None,
        notes: Optional[str] = None
    ) -> Transaction:
        """
        Mark transaction as completed
        Invoice number will be auto-generated by database trigger
        """
        result = await db.execute(
            select(Transaction).where(Transaction.id == transaction_id)
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            raise ValueError(f"Transaction not found: {transaction_id}")
        
        if transaction.status == TransactionStatus.COMPLETED:
            return transaction  # Already completed
        
        transaction.status = TransactionStatus.COMPLETED
        transaction.completed_at = datetime.utcnow()
        
        if payment_reference:
            transaction.payment_reference = payment_reference
        
        if notes:
            transaction.notes = notes
        
        await db.commit()
        await db.refresh(transaction)
        
        return transaction
    
    @staticmethod
    async def fail_transaction(
        db: AsyncSession,
        transaction_id: UUID,
        notes: Optional[str] = None
    ) -> Transaction:
        """Mark transaction as failed"""
        result = await db.execute(
            select(Transaction).where(Transaction.id == transaction_id)
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            raise ValueError(f"Transaction not found: {transaction_id}")
        
        transaction.status = TransactionStatus.FAILED
        
        if notes:
            transaction.notes = notes
        
        await db.commit()
        await db.refresh(transaction)
        
        return transaction
    
    @staticmethod
    async def refund_transaction(
        db: AsyncSession,
        transaction_id: UUID,
        refund_amount: Optional[Decimal] = None,
        notes: Optional[str] = None
    ) -> Transaction:
        """
        Process a refund for a transaction
        Creates a new refund transaction
        """
        # Get original transaction
        result = await db.execute(
            select(Transaction).where(Transaction.id == transaction_id)
        )
        original = result.scalar_one_or_none()
        
        if not original:
            raise ValueError(f"Transaction not found: {transaction_id}")
        
        if original.status != TransactionStatus.COMPLETED:
            raise ValueError("Can only refund completed transactions")
        
        # Use original amount if refund_amount not specified
        if refund_amount is None:
            refund_amount = original.amount
        
        if refund_amount > original.amount:
            raise ValueError("Refund amount cannot exceed original amount")
        
        # Create refund transaction
        refund = Transaction(
            company_id=original.company_id,
            subscription_id=original.subscription_id,
            transaction_type='refund',
            amount=refund_amount,
            currency=original.currency,
            payment_method=original.payment_method,
            status=TransactionStatus.COMPLETED,
            completed_at=datetime.utcnow(),
            description=f"Refund for transaction {original.invoice_number or str(original.id)}",
            notes=notes,
            transaction_metadata={
                "original_transaction_id": str(original.id),
                "original_invoice_number": original.invoice_number
            }
        )
        
        # Mark original as refunded if full refund
        if refund_amount == original.amount:
            original.status = TransactionStatus.REFUNDED
        
        db.add(refund)
        await db.commit()
        await db.refresh(refund)
        
        return refund
    
    @staticmethod
    async def create_subscription_transaction(
        db: AsyncSession,
        company_id: UUID,
        subscription_id: UUID,
        payment_method: Optional[PaymentMethod] = None
    ) -> Transaction:
        """
        Create transaction for subscription payment
        Calculates amount based on subscription plan and billing cycle
        """
        # Get subscription
        result = await db.execute(
            select(CompanySubscription).where(CompanySubscription.id == subscription_id)
        )
        subscription = result.scalar_one_or_none()
        
        if not subscription:
            raise ValueError(f"Subscription not found: {subscription_id}")
        
        # Get plan
        plan = await SubscriptionService.get_plan_by_id(db, subscription.plan_id)
        if not plan:
            raise ValueError(f"Plan not found: {subscription.plan_id}")
        
        # Calculate amount based on billing cycle
        if subscription.billing_cycle == 'yearly':
            amount = plan.yearly_price
            description = f"Yearly subscription - {plan.name}"
        else:
            amount = plan.monthly_price
            description = f"Monthly subscription - {plan.name}"
        
        # Create transaction
        return await BillingService.create_transaction(
            db=db,
            company_id=company_id,
            amount=amount,
            transaction_type='subscription',
            subscription_id=subscription_id,
            payment_method=payment_method,
            description=description,
            transaction_metadata={
                "plan_slug": plan.slug,
                "plan_name": plan.name,
                "billing_cycle": subscription.billing_cycle
            }
        )
    
    @staticmethod
    async def get_company_transactions(
        db: AsyncSession,
        company_id: UUID,
        skip: int = 0,
        limit: int = 100,
        status: Optional[TransactionStatus] = None
    ) -> List[Transaction]:
        """Get all transactions for a company"""
        query = select(Transaction).where(Transaction.company_id == company_id)
        
        if status:
            query = query.where(Transaction.status == status)
        
        query = query.order_by(Transaction.transaction_date.desc()).offset(skip).limit(limit)
        
        result = await db.execute(query)
        return list(result.scalars().all())
    
    @staticmethod
    async def get_transaction_by_id(
        db: AsyncSession,
        transaction_id: UUID
    ) -> Optional[Transaction]:
        """Get transaction by ID"""
        result = await db.execute(
            select(Transaction).where(Transaction.id == transaction_id)
        )
        return result.scalar_one_or_none()
    
    @staticmethod
    async def get_transaction_by_invoice(
        db: AsyncSession,
        invoice_number: str
    ) -> Optional[Transaction]:
        """Get transaction by invoice number"""
        result = await db.execute(
            select(Transaction).where(Transaction.invoice_number == invoice_number)
        )
        return result.scalar_one_or_none()
    
    @staticmethod
    async def get_revenue_stats(
        db: AsyncSession,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None
    ) -> dict:
        """
        Get revenue statistics
        
        Returns:
            dict with total_revenue, completed_count, pending_amount, etc.
        """
        from sqlalchemy import func
        
        query = select(
            func.count(Transaction.id).label('total_count'),
            func.sum(Transaction.amount).filter(Transaction.status == TransactionStatus.COMPLETED).label('total_revenue'),
            func.count(Transaction.id).filter(Transaction.status == TransactionStatus.COMPLETED).label('completed_count'),
            func.sum(Transaction.amount).filter(Transaction.status == TransactionStatus.PENDING).label('pending_amount'),
            func.count(Transaction.id).filter(Transaction.status == TransactionStatus.FAILED).label('failed_count')
        )
        
        if start_date:
            query = query.where(Transaction.transaction_date >= start_date)
        
        if end_date:
            query = query.where(Transaction.transaction_date <= end_date)
        
        result = await db.execute(query)
        row = result.first()
        
        return {
            "total_transactions": row.total_count or 0,
            "total_revenue": float(row.total_revenue or 0),
            "completed_count": row.completed_count or 0,
            "pending_amount": float(row.pending_amount or 0),
            "failed_count": row.failed_count or 0
        }
    
    @staticmethod
    async def process_payment_webhook(
        db: AsyncSession,
        payment_reference: str,
        status: str,
        gateway_response: dict
    ) -> Optional[Transaction]:
        """
        Process payment gateway webhook
        
        Args:
            db: Database session
            payment_reference: External payment reference
            status: Payment status from gateway ('success', 'failed', etc.)
            gateway_response: Full response from payment gateway
        
        Returns:
            Updated Transaction or None if not found
        """
        # Find transaction by payment reference
        result = await db.execute(
            select(Transaction).where(Transaction.payment_reference == payment_reference)
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            return None
        
        # Update transaction based on gateway status
        if status.lower() in ['success', 'completed', 'paid']:
            transaction.status = TransactionStatus.COMPLETED
            transaction.completed_at = datetime.utcnow()
        elif status.lower() in ['failed', 'declined', 'error']:
            transaction.status = TransactionStatus.FAILED
        
        # Store gateway response in transaction_metadata
        if transaction.transaction_metadata:
            transaction.transaction_metadata['gateway_response'] = gateway_response
        else:
            transaction.transaction_metadata = {'gateway_response': gateway_response}
        
        await db.commit()
        await db.refresh(transaction)
        
        return transaction
